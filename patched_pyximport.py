import pyximport
from pathlib import Path
import importlib
import sys
import pickle
from dataclasses import dataclass
import os

from Cython.Compiler import Options
from Cython.Build.Dependencies import create_dependency_tree, create_extension_list, DistutilsInfo
from Cython.Distutils.build_ext import build_ext
from typing import Iterable, Set, MutableSet, Mapping, MutableMapping, Tuple
from Cython.Compiler.Options import CompilationOptions
from Cython.Compiler.Main import Context

# Temporary directories are long because pyximport "doubles" the parent directory path.

def new_finalize_options(bld_ext):
    old_finalize_options = bld_ext.finalize_options
    def finalize_options(bld_ext):
        bld_ext.build_temp = str(Path.home().joinpath("_pyxbld").joinpath("temp"))
        old_finalize_options(bld_ext)
    return finalize_options

def replace_cython_build_ext():
    build_ext.finalize_options = new_finalize_options(build_ext)

@dataclass
class PathStat:
    st_mtime: float
    st_size: int

    @staticmethod
    def from_path(path: Path):
        stat = path.stat()
        return PathStat(stat.st_mtime, stat.st_size)

class RecordedPathStatsManager:
    ref_dir: Path
    stats_path: Path
    dependency_map_path: Path

    # "self.stats" maps source and dependency combination to the recorded timestamp
    # for the dependency where the recorded timestamp was recorded with the last compilation of source
    # Note that the source is a dependency of itself.
    stats: MutableMapping[Tuple[Path, Path], PathStat]

    # "self.dependency_map" maps source to the recorded set of dependencies
    # for the source  where the recorded set of dependencies was recorded
    # with the last compilation of source
    # Note that the source is a dependency of itself.
    dependency_map: MutableMapping[Path, MutableSet[Path]]

    def __init__(self, ref_dir: Path):
        self.ref_dir = ref_dir

        self.stats_path = self.ref_dir.joinpath("recorded_stats.pkl")
        self.dependency_map_path = self.ref_dir.joinpath("recorded_dependency_map.pkl")

        self.stats = load_object(self.stats_path, default = {})
        self.dependency_map = load_object(self.dependency_map_path, default = {})
        # self.dependency_tree = create_dependency_tree()

    # def update_stats_for_path(self, path):
    #     self.stats[path)] = PathStat.from_path(path)
    #     self.save_stats()

    def module_stats_has_changed(self, source: Path, dependencies: Iterable[Path]):
        return module_stats_has_changed(source, dependencies, self.stats, self.dependency_map)

    def module_dependencies_has_changed(self, source: Path, dependencies: Iterable[Path]):
        return module_dependencies_has_changed(source, dependencies, self.dependency_map)

    def update_dependencies_for_module(self, source: Path, dependencies: Iterable[Path]):

        if self.module_dependencies_has_changed(source, dependencies):
            prev_dependencies = self.dependency_map.get(source, [])

            self.dependency_map[source] = set(dependencies)
            save_object(self.dependency_map, self.dependency_map_path)

            recorded_stats_have_changed = False

            for prev_dependency in prev_dependencies:
                if prev_dependency not in dependencies:
                    del self.stats[source, prev_dependency]
                    recorded_stats_have_changed = True

            if recorded_stats_have_changed:
                save_object(self.stats, self.stats_path)

    def update_stats_for_module(self, source: Path, dependencies: Iterable[Path]):
        self.update_dependencies_for_module(source, dependencies)

        if self.module_stats_has_changed(source, dependencies):
            for dependency in dependencies:
                self.stats[(source, dependency)] = (
                    PathStat.from_path(dependency)
                )
            save_object(self.stats, self.stats_path)

    # def check_and_touch_one(self, path):
    #     path = Path(path)
    #     if self.stats.get(path)) != PathStat.from_path(path):
    #         path.touch()
    #         self.update_stats_for_path(path)

    # def check_and_touch_dependencies(self, source):
    #     str_dependencies = self.dependency_tree.all_dependencies(str(source))
    #
    #     for str_path in str_dependencies:
    #         self.check_and_touch_one(str_path)

def cython_will_compile(source: Path, dependencies: Iterable[Path]):
    will_compile = False

    ext = source.suffix
    source_as_str = str(source)
    info = DistutilsInfo(source_as_str).values
    if ext in ('.pyx', '.py'):
        if info.get("np_pythran", False):
            c_path = source.with_suffix('.cpp')
        elif info.get("language") == 'c++':
            c_path = source.with_suffix('.cpp')
        else:
            c_path = source.with_suffix('.c')

        # Missing files and those generated by other Cython versions should always be recreated.
        # TODO: next few line needs to be updated for future versions of Cython
        if c_path.exists():
            c_timestamp = c_path.stat().st_mtime
        else:
            c_timestamp = -1

        # Priority goes first to modified files, second to direct
        # dependents, and finally to indirect dependents.
        for dependency in dependencies:
            if dependency.stat().st_mtime > c_timestamp:
                return True

        return False


def module_stats_has_changed(
    source: Path,
    dependencies: Iterable[Path],
    recorded_stats: Mapping[Tuple[Path, Path], PathStat],
    recorded_dependency_map: Mapping[Path, Set[Path]]
):
    if module_dependencies_has_changed(source, dependencies, recorded_dependency_map):
        return True

    current_dependency_stats = [
        PathStat.from_path(dependency)
        for dependency
        in dependencies
    ]
    recorded_dependency_stats = [
        recorded_stats.get((source, dependency))
        for dependency
        in dependencies
    ]

    return current_dependency_stats != recorded_dependency_stats

def module_dependencies_has_changed(
    source: Path,
    dependencies: Iterable[Path],
    recorded_dependency_map: Mapping[Path, Set[Path]]
):
    return set(dependencies) !=  recorded_dependency_map.get(source)

def save_object(obj, path: Path):
    if not path.parent.exists():
        path.parent.mkdir(parents=True, exist_ok=True)

    with open(path, 'wb') as save_file:
        pickle.dump(obj, save_file)

def load_object(path: Path, default):
    obj = default

    if path.exists():
        with open(path, 'rb') as load_file:
            obj = pickle.load(load_file)

    return obj

#
# def module_is_up_to_date(source, dependencies, recorded_stats):
#     current_dependency_stats = [
#         PathStat.from_path(dependency)
#         for dependency
#         in dependencies
#     ]
#     recorded_dependency_stats = [
#         recorded_stats.get((source, dependency))
#         for dependency
#         in dependencies
#     ]
#
#     return current_dependency_stats == recorded_dependency_stats


def get_path_from_spec(spec, ext):

        if not spec:
            return None

        if not spec.loader:
            return None

        if not spec.origin:
            return None

        path = Path(spec.origin)

        if path.stem == "__init__":
            return None

        if path.suffix != ext:
            return None

        return path


def uninstall_importers():
    for importer in sys.meta_path:
        if isinstance(importer, pyximport.PyxImporter):
            sys.meta_path.remove(importer)


def package_dir(source: Path, fullname: str):
    mod_split = fullname.split(".")

    if len(mod_split) == 1:
        # This is a free module
        return source.parent
    else:
        # This module is in a package
        modname = mod_split.pop()
        dir = source.parent

        while len(mod_split) > 1:
            pkg_name = mod_split.pop()
            if pkg_name != dir.name:
                # It is not safe to go up a directory because names are mismatched
                return dir #
            dir = dir.parent

        return dir

class PyPxdImporter(pyximport.PyImporter):
    """
        Compiles .py files only if there is an accompanying .pxd file
    """
    def __init__(self, recorded_stats_manager, pyxbuild_dir=None, inplace=False, language_level=None):
        pyximport.PyImporter.__init__(
            self,
            pyxbuild_dir=pyxbuild_dir,
            inplace=inplace,
            language_level=language_level
        )
        self.checked_names = set()
        self.recorded_stats_manager = recorded_stats_manager
        self.dependency_tree = create_dependency_tree()

    def find_module(self, fullname, package_path=None):

        if fullname in self.checked_names:
            return None
        else:
            self.checked_names.add(fullname)
            spec = importlib.util.find_spec(fullname)

        source = get_path_from_spec(spec, ".py")

        if source is not None:
            pxd_path = source.parent.joinpath(source.stem).with_suffix(".pxd")

            if pxd_path.exists():
                str_dependencies = self.dependency_tree.all_dependencies(str(source))
                dependencies = set(Path(str_path) for str_path in str_dependencies)

                if not cython_will_compile(source, dependencies):
                    if self.recorded_stats_manager.module_stats_has_changed(source, dependencies):
                        print(f"Patched Pyximport is touching {str(source)} to ensure compilation")
                        source.touch()

                self.recorded_stats_manager.update_stats_for_module(source, dependencies)
                self.pyxbuild_dir = package_dir(source, fullname).joinpath("_pyxbld")
                return pyximport.PyImporter.find_module(self, fullname, package_path)
            else:
                return None
        else:
            return None


class PyxImporter(pyximport.PyxImporter):
    """
        Compiles .pyx files
    """
    def __init__(self, recorded_stats_manager, extension=pyximport.PYX_EXT, pyxbuild_dir=None, inplace=False, language_level=None):
        pyximport.PyxImporter.__init__(
            self,
            extension=extension,
            pyxbuild_dir=pyxbuild_dir,
            inplace=inplace,
            language_level=language_level
        )

        self.recorded_stats_manager = recorded_stats_manager
        self.dependency_tree = create_dependency_tree()

    def find_module(self, fullname, package_path=None):

        loader = pyximport.PyxImporter.find_module(self, fullname, package_path)

        if loader is not None:
            source = Path(loader.path)

            str_dependencies = self.dependency_tree.all_dependencies(str(source))
            dependencies = set(Path(str_path) for str_path in str_dependencies)

            if not cython_will_compile(source, dependencies):
                if self.recorded_stats_manager.module_stats_has_changed(source, dependencies):
                    print(f"Patched Pyximport is touching {str(source)} to ensure compilation")
                    source.touch()

            self.recorded_stats_manager.update_stats_for_module(source, dependencies)
            loader.pyxbuild_dir = package_dir(source, fullname).joinpath("_pyxbld")

        return loader

def install(annotating = True, recorded_stats_dir = None):

    replace_cython_build_ext()

    if recorded_stats_dir is None:
        recorded_stats_dir = Path.home().joinpath("_pyxbld")
    recorded_stats_manager = RecordedPathStatsManager(Path(recorded_stats_dir))

    # Next line is needed to define 'pyxargs'
    pyximport.install(build_in_temp = False)

    uninstall_importers()

    Options.annotate = annotating;

    py_pxd_importer = PyPxdImporter(recorded_stats_manager, language_level=3)
    pyx_importer = PyxImporter(recorded_stats_manager, language_level=3)

    # make sure we import Cython before we install the import hook
    import Cython.Compiler.Main, Cython.Compiler.Pipeline, Cython.Compiler.Optimize
    sys.meta_path.insert(0, py_pxd_importer)
    sys.meta_path.insert(0, pyx_importer)

